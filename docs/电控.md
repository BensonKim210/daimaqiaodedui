# CRTC2025机器人电控系统详细日志
## 一、项目概况
本日志详细记录CRTC2025校级训练赛机器人电控系统的**硬件接线、功能开发与系统调试**全流程，涵盖**滚筒电机驱动、机器人遥控、主控系统集成**三大核心功能。基于STM32F103C8T6主控、L298N驱动模块、PS2手柄等硬件（硬件清单见用户提供的采购表），从“硬件物理连接”到“软件逻辑实现”完整呈现，确保电控系统与机械滚筒式收集装置的功能协同性。


## 二、滚筒式收集装置电机驱动控制（10月1日-10月7日）
### 功能描述
通过**L298N直流电机驱动模块**控制滚筒电机的转速与转向，实现17mm弹丸的“抓取-传输-存储”全流程动力支持。需保证电机在负载下转速稳定，且硬件接线安全可靠，适配机械滚筒的结构特性。

### 硬件选型与准备
- **主控**：STM32F103C8T6（2个，单价10.19元，总价20.38元），选择其GPIOA引脚组实现控制信号输出。
- **驱动模块**：L298N（4个，单价10.23元，总价40.92元），单路最大输出电流2A，满足TT直流减速电机（赛事指定）的功率需求。
- **电源**：18650电池盒（2个，单价2.8元，总价5.6元），串联输出12V电压，为L298N和电机供电；STM32由独立5V电源（如USB转5V模块）供电，避免电源干扰。
- **电机**：赛事指定TT直流减速电机（减速比1:120），输出轴与机械滚筒的传动滑轮连接。

### 详细接线过程
1. **L298N与电源连接**
   - 将18650电池盒的“+”极接L298N的“+12V”输入端子，“-”极接“GND”端子；
   - 为避免电源波动，在“+12V”与“GND”之间并联一个220μF/25V电解电容和0.1μF瓷片电容。

2. **L298N与STM32连接**
   - L298N的**IN1引脚**（控制电机A相转向）接STM32的**GPIOA0**（推挽输出模式）；
   - L298N的**IN2引脚**（控制电机A相转向）接STM32的**GPIOA1**（推挽输出模式）；
   - L298N的**ENA引脚**（电机A相使能，PWM输入）接STM32的**GPIOA4**（复用为TIM2_CH1，PWM输出模式）；
   - L298N的**GND**引脚与STM32的**GND**引脚共地，确保信号参考电平一致。

3. **L298N与电机连接**
   - 将TT电机的两根引线分别接L298N的**OUT1**和**OUT2**端子（电机正转/反转由IN1、IN2电平组合控制）。

### 开发历程
- 10月3日：完成上述硬件接线后，使用万用表检测各节点电压，确认电源极性、引脚连接无误，避免短路风险。
- 10月5日：编写PWM驱动代码（见下文示范代码），通过调节TIM2的PWM占空比，实现电机转速从0%到100%的线性调节，验证硬件接线的信号传输可靠性。
- 10月7日：将电机与机械滚筒的传动滑轮装配，在负载条件下测试电机转速，最终确定PWM占空比70%为最佳效率点（弹丸收集无卡顿且电机无过热）。


### 示范代码（滚筒电机驱动控制）
```c
#include "stm32f10x.h"

// L298N控制引脚定义（与硬件接线一一对应）
#define IN1_PIN GPIO_Pin_0
#define IN2_PIN GPIO_Pin_1
#define ENA_PIN GPIO_Pin_4
#define GPIO_PORT GPIOA

// 电机初始化：配置GPIO与PWM
void RollerMotor_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStruct;
    TIM_OCInitTypeDef TIM_OCInitStruct;
    
    // 使能GPIOA和TIM2时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    
    // 配置IN1/IN2为推挽输出（控制电机方向）
    GPIO_InitStruct.GPIO_Pin = IN1_PIN | IN2_PIN;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIO_PORT, &GPIO_InitStruct);
    
    // 配置ENA为PWM输出引脚（复用功能）
    GPIO_InitStruct.GPIO_Pin = ENA_PIN;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIO_PORT, &GPIO_InitStruct);
    
    // 初始化TIM2生成PWM（频率1kHz，周期1000us）
    TIM_TimeBaseStruct.TIM_Period = 999;        
    TIM_TimeBaseStruct.TIM_Prescaler = 71;       
    TIM_TimeBaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStruct);
    
    // 配置PWM模式为PWM1
    TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCInitStruct.TIM_Pulse = 0;
    TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;
    TIM_OC1Init(TIM2, &TIM_OCInitStruct);  // ENA对应TIM2_CH1
    
    TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);
    TIM_ARRPreloadConfig(TIM2, ENABLE);
    TIM_Cmd(TIM2, ENABLE);
}

// 滚筒电机正转（speed范围：0~999，对应占空比0%~100%）
void RollerMotor_Forward(uint16_t speed) {
    GPIO_SetBits(GPIO_PORT, IN1_PIN);
    GPIO_ResetBits(GPIO_PORT, IN2_PIN);
    TIM_SetCompare1(TIM2, speed);
}

// 滚筒电机停止
void RollerMotor_Stop(void) {
    GPIO_ResetBits(GPIO_PORT, IN1_PIN | IN2_PIN);
    TIM_SetCompare1(TIM2, 0);
}

int main(void) {
    SystemInit();
    RollerMotor_Init();
    while(1) {
        RollerMotor_Forward(700); // 70%占空比，负载下弹丸收集效率最优
    }
}
```


## 三、机器人遥控系统搭建（10月8日-10月15日）
### 功能描述
通过**PS2手柄**（蓝色横插式，2个，总价76元）实现机器人的“移动控制（底盘电机）”与“滚筒装置启停/转速调节”。需保证手柄与STM32的通信稳定，按键映射逻辑符合赛事操作习惯，遥控响应延迟≤100ms。

### 硬件选型与准备
- **遥控模块**：PS2手柄（通信协议为SPI变种），选择其DATA、CMD、CLK、ATT引脚实现与STM32的通信。
- **主控**：STM32F103C8T6，使用GPIOB引脚组处理手柄通信信号。

### 详细接线过程
1. **PS2手柄与STM32连接**
   - PS2手柄的**DATA引脚**（数据输入）接STM32的**GPIOB0**（上拉输入模式）；
   - PS2手柄的**CMD引脚**（命令输出）接STM32的**GPIOB1**（推挽输出模式）；
   - PS2手柄的**CLK引脚**（时钟输出）接STM32的**GPIOB2**（推挽输出模式）；
   - PS2手柄的**ATT引脚**（片选输出）接STM32的**GPIOB3**（推挽输出模式）；
   - PS2手柄的**VCC引脚**接5V电源，**GND引脚**与STM32的**GND**共地。

### 开发历程
- 10月8日：完成硬件接线后，使用示波器观测CLK和DATA引脚的波形，确认通信时序符合PS2协议规范。
- 10月10日：编写PS2手柄驱动代码（见下文示范代码），实现按键状态、摇杆数据的实时读取，通过串口打印验证数据准确性。
- 10月13日：建立“左摇杆控制底盘移动、圆形按键控制滚筒启停、十字键调节滚筒转速”的映射逻辑，在面包板上模拟按键输入，验证功能触发的可靠性。
- 10月15日：在2.4m×2.4m的模拟场地中进行遥控距离测试，确认无遮挡时有效控制距离≥5m，满足赛事场地需求。


### 示范代码（PS2手柄驱动与控制逻辑）
```c
#include "stm32f10x.h"

// PS2手柄引脚定义（与硬件接线一一对应）
#define PS2_DATA_PIN GPIO_Pin_0
#define PS2_CMD_PIN GPIO_Pin_1
#define PS2_CLK_PIN GPIO_Pin_2
#define PS2_ATT_PIN GPIO_Pin_3
#define PS2_PORT GPIOB

// PS2手柄数据结构
typedef struct {
    uint16_t buttons;  // 按键状态（每一位对应一个按键）
    uint8_t left_x;    // 左摇杆X轴（0~255）
    uint8_t left_y;    // 左摇杆Y轴（0~255）
    uint8_t right_x;   // 右摇杆X轴（0~255）
    uint8_t right_y;   // 右摇杆Y轴（0~255）
} PS2_Data_t;

// PS2手柄GPIO初始化
void PS2_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    
    // CMD/CLK/ATT配置为推挽输出
    GPIO_InitStruct.GPIO_Pin = PS2_CMD_PIN | PS2_CLK_PIN | PS2_ATT_PIN;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(PS2_PORT, &GPIO_InitStruct);
    
    // DATA配置为上拉输入
    GPIO_InitStruct.GPIO_Pin = PS2_DATA_PIN;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(PS2_PORT, &GPIO_InitStruct);
}

// PS2手柄通信时序实现（读取手柄数据）
void PS2_Read(PS2_Data_t *data) {
    uint8_t cmd[9] = {0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    uint8_t rx_buf[9] = {0};
    uint8_t i;
    
    // 拉低ATT（片选有效）
    GPIO_ResetBits(PS2_PORT, PS2_ATT_PIN);
    delay_us(10); // 延时确保稳定
    
    // 发送命令字节
    for (i = 0; i < 9; i++) {
        GPIO_ResetBits(PS2_PORT, PS2_CLK_PIN);
        if (cmd[i] & 0x01) {
            GPIO_SetBits(PS2_PORT, PS2_CMD_PIN);
        } else {
            GPIO_ResetBits(PS2_PORT, PS2_CMD_PIN);
        }
        delay_us(5);
        GPIO_SetBits(PS2_PORT, PS2_CLK_PIN);
        delay_us(5);
        cmd[i] >>= 1;
    }
    
    // 读取返回数据
    for (i = 0; i < 9; i++) {
        uint8_t byte = 0;
        GPIO_ResetBits(PS2_PORT, PS2_CLK_PIN);
        delay_us(5);
        for (uint8_t j = 0; j < 8; j++) {
            GPIO_SetBits(PS2_PORT, PS2_CLK_PIN);
            delay_us(2);
            byte |= (GPIO_ReadInputDataBit(PS2_PORT, PS2_DATA_PIN) << j);
            GPIO_ResetBits(PS2_PORT, PS2_CLK_PIN);
            delay_us(2);
        }
        rx_buf[i] = byte;
    }
    
    // 释放ATT（片选无效）
    GPIO_SetBits(PS2_PORT, PS2_ATT_PIN);
    delay_us(10);
    
    // 解析数据到结构体
    data->buttons = (rx_buf[3] << 8) | rx_buf[4];
    data->left_x = rx_buf[5];
    data->left_y = rx_buf[6];
    data->right_x = rx_buf[7];
    data->right_y = rx_buf[8];
}

// 主控制逻辑：手柄输入映射到机器人动作
int main(void) {
    SystemInit();
    RollerMotor_Init(); // 引用滚筒电机初始化函数
    PS2_Init();
    
    while(1) {
        PS2_Data_t ps2_data;
        PS2_Read(&ps2_data);
        
        // 滚筒电机控制：圆形按键（假设对应buttons第3位）按下启动，松开停止
        if (!(ps2_data.buttons & (1 << 3))) {
            RollerMotor_Forward(700);
        } else {
            RollerMotor_Stop();
        }
        
        // 底盘电机控制：左摇杆Y轴（0~255）映射为速度（-127~127）
        int16_t chassis_speed = (ps2_data.left_y - 128);
        // 此处需添加底盘电机驱动代码，如差速控制等
    }
}
```


## 四、主控程序集成与系统调试（10月16日-10月22日）
### 功能描述
将**滚筒电机驱动、PS2遥控**等功能集成到STM32F103C8T6主控中，实现“遥控指令-电机执行-状态反馈”的闭环控制。同时通过硬件调试（如STLink在线调试）解决模块冲突、逻辑漏洞，确保赛事场景下的稳定性与可靠性。

### 硬件选型与准备
- **调试工具**：STLink（1个，总价13.49元），用于STM32程序下载与在线调试。
- **辅助硬件**：杜邦线（杜绑线，15cm母对母+公对母+公对公组合，总价9.53元），用于临时接线与模块扩展。

### 详细接线过程（系统集成阶段）
1. **STLink与STM32连接**
   - STLink的**SWDIO引脚**接STM32的**PA13**，**SWCLK引脚**接STM32的**PA14**；
   - STLink的**GND引脚**与STM32的**GND**共地，**3.3V引脚**为STM32提供调试供电（也可由独立电源供电）。

2. **系统供电整合**
   - 18650电池盒的12V输出同时为L298N和底盘电机供电；
   - 新增5V降压模块（如LM2596），将12V转换为5V，为PS2手柄和STM32的外设供电；
   - STM32的核心电源由其自身的3.3V稳压模块提供，确保供电分层稳定。

### 开发历程
- 10月16日：基于STM32F103C8T6，将滚筒电机驱动、PS2遥控的代码模块整合，解决引脚复用冲突（如GPIOA同时用于电机驱动和其他功能时的配置问题）。
- 10月18日：使用STLink进行程序下载与在线断点调试，定位并解决“电机启动时遥控信号丢失”的时序冲突问题（最终通过调整模块初始化顺序解决）。
- 10月20日：在“机械滚筒+电控系统”的整机环境下，进行功能联调——通过PS2手柄启动滚筒，验证弹丸收集流程；通过左摇杆控制底盘移动，验证地形通过性，记录并解决“滚筒与底盘动作不同步”的逻辑漏洞。
- 10月22日：添加硬件保护机制，如通过ADC采集电池电压（18650电池盒电压），当电压低于9V时自动关闭电机；通过GPIO检测电机堵转信号，当滚筒卡死时立即停机，确保赛事中机器人的安全运行。


### 示范代码（主控系统集成与保护机制）
```c
#include "stm32f10x.h"
#include "roller_motor.h"
#include "ps2.h"
#include "adc.h" // 假设已实现ADC采集电池电压的头文件

// 电池欠压阈值（单位：V）
#define BATTERY_LOW_THRESHOLD 9.0f

// 电池电压采集初始化
void Battery_ADC_Init(void) {
    // 配置STM32的ADC通道，采集电池电压（需分压电路将12V转换为0~3.3V）
    // 此处省略ADC初始化代码，实际项目中需完善
}

// 读取电池电压（返回值：V）
float Get_BatteryVoltage(void) {
    uint16_t adc_value = ADC_GetConversionValue(ADC1);
    // 假设分压比为1/4，ADC参考电压3.3V
    return (adc_value * 3.3f / 4095.0f) * 4; 
}

int main(void) {
    SystemInit();
    RollerMotor_Init();
    PS2_Init();
    Battery_ADC_Init();
    
    while(1) {
        PS2_Data_t ps2_data;
        PS2_Read(&ps2_data);
        
        // 电池欠压保护
        if (Get_BatteryVoltage() < BATTERY_LOW_THRESHOLD) {
            RollerMotor_Stop();
            // 底盘电机停止代码
            continue;
        }
        
        // 滚筒电机控制
        if (!(ps2_data.buttons & (1 << 3))) {
            RollerMotor_Forward(700);
        } else {
            RollerMotor_Stop();
        }
        
        // 底盘电机控制
        int16_t chassis_speed = (ps2_data.left_y - 128);
        // 底盘电机驱动代码
    }
}
```